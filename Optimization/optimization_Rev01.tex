\documentclass[12pt]{article}
\usepackage{geometry}
\geometry{a4paper, margin=1in}
\usepackage{hyperref}
\usepackage{amsmath, amssymb}
\usepackage{graphicx}
\usepackage{enumitem}
\usepackage{subcaption}

\title{Optimization}
\author{}
\date{}

\begin{document}

\maketitle

\section*{Introduction}

The evolution of software development has challenged project management, resource allocation, and quality assurance []. In the early days, software was often delivered as a single version that remained unchanged for years. Hardware was less diversified, and systems were independent, with minimal integrations or updates. However, complexity grew exponentially as technology advanced, necessitating more features, frequent updates, and extensive integrations with third-party systems such as APIs and cloud services [].

These changes have made project management and scheduling techniques indispensable. Today, large companies must navigate an ever-growing volume of software releases, ranging from patches to address critical security vulnerabilities, updates to improve performance, or add new features to maintain a competitive product. Each release plays a role in maintaining software quality, minimizing customer impact, and ensuring satisfaction. The increasingly fragmented software development nature presents challenges similar to the ones faced in manufacturing industries, where job scheduling techniques are widely applied to optimize resource use and minimize costs []. %Similarly, the increasingly fragmented and complex nature of software development calls for advanced scheduling strategies. 

The Job Scheduling Problem (JSP) has been widely studied, yet its complexity remains a challenge in real-world applications. Varying corporate paradigms and distinct objective functions necessitate adaptable solutions, as some projects require urgent completion while others demand precise timing to avoid delays []. Despite extensive research, most scheduling models are designed for specific objectives: minimizing lateness, reducing makespan, or ensuring just-in-time completion, making them inflexible when priorities are mixed []. While some multi-objective models exist, they often rely on fixed trade-offs or require substantial modification to accommodate different goals []. There is a clear need for a unified, parameter-driven scheduling model that can adapt across scheduling paradigms without requiring model redefinition.

%Job scheduling, when applied to software management, can help estimate how much resources we need to help new features get to the final user when promised, or prioritize the tasks to give the least amount of impact on the final user. 
%The job scheduling problem (JSP) has been widely studied, yet its complexity continues to present challenges in real-world applications []. Factors such as varying corporate paradigms, or distinct objective functions necessitate tailored solutions. For example, some projects must be expedited to meet urgent business goals, while others require precise timing to avoid premature or late completion. Addressing this diversity requires mathematical models capable of adapting to multiple objectives and constraints, ensuring an optimal balance between competing priorities [].

%Despite extensive research on job scheduling optimization, most mathematical models are designed with specific objectives in mind, such as minimizing lateness, reducing makespan, or ensuring just-in-time completion []. While some multi-objective models exist, they typically require predefined trade-offs or fixed structures that limit their adaptability []. Additionally, many existing formulations require substantial modification or entirely separate models to accommodate different goals, making them inflexible for real-world scenarios where scheduling priorities shift dynamically. There is a clear urge for a unified, parameter-driven scheduling model that allows adaptation across scheduling paradigms without redefining the objective function. %This research aims to address this gap by proposing a versatile mathematical framework that integrates multiple scheduling objectives into a single, adaptable formulation.

%Despite extensive research on job scheduling optimization, most mathematical models have specific objectives, such as minimizing lateness, reducing makespan, or ensuring just-in-time completion. This limits their applicability when multiple objectives or dynamic priorities coexist []. Additionally, many existing formulations require substantial modification or entirely separate models to accommodate different goals, making them inflexible for real-world use cases where priorities can shift rapidly. There is a clear gap in the literature for a unified and adaptable scheduling model that can address varying objectives by simply adjusting parameters, enabling seamless customization for scenarios like just-in-time scheduling, minimizing lateness, or balancing resource utilization without the need for model redefinition.

%The literature shows a clear challenge of taking a specific problem and defining a mathematical formulation based on expertise. These problems calls for a unified and adaptable scheduling model that can address varying objectives by simply adjusting parameters, enabling seamless customization for scenarios like just-in-time scheduling, minimizing lateness, or balancing resource utilization without the need for model redefinition.

%This research proposes a customized approach to optimizing the software validation process scheduling. It uses a mixed integer linear programming (ILP) model with hyperparameters that simulate the behavior of multiple scheduling objectives within a single formulation. The model achieves adaptability by parameterizing item aspects such as deadlines, penalties for lateness or earliness, and resource constraints, allowing practitioners to prioritize different objectives without altering the core structure. 

%This paradigm of modifying the items instead of modifying the mathematical model can provide companies the possibility to apply optimization algorithms on their processes (either software management, manufacturing, or any other field) without the need of an expert dedicated to model the problem from zero. This flexibility not only reduces the complexity of deploying scheduling optimization across varying scenarios but also enhances its practical relevance, particularly in dynamic environments where we need to account different objectives and constraints. 

%We also introduce a way to understand if we have enough resources to achieve our results on time, this idea can provide insightful information for stakeholds to understand if more investments are needed or if we could increase the demands.

%This research proposes a flexible mixed integer linear programming (ILP) model for software validation scheduling. By adjusting hyperparameters instead of the model, multiple scheduling objectives can be achieved within a single formulation. This method intends to simplify deployment across industries and ensure efficient scheduling in dynamic environments. Additionally, the model provides insights into resource sufficiency, helping stakeholders assess capacity and investment needs.

This study proposes a flexible Integer Linear Programming (ILP) formulation for software validation scheduling [], allowing multiple scheduling behaviors within a single objective function by adjusting the job's hyperparameters instead of the model. This method intends to simplify deployment across industries and ensures optimal scheduling in dynamic environments. %Additionally, the model provides insights into resource sufficiency, helping stakeholders assess capacity and investment needs.

\section*{Related Works}

%\subsection*{Scheduling Formulations}
Scheduling problems are defined by mathematical models specifying an objective function and constraints. Jackson (1955) proposed a formulation that minimized maximal lateness in single-machine. Bruno et al. (1973) extended the shortest processing time rule with weighted completion times for job prioritization. Zambrano Rey (2020) introduced a just-in-time scheduling formulation using a mean squared error function around due dates, penalizing both early and late completions. Due to its complexity, he applied genetic algorithms (GA) and particle swarm optimization. Recent efforts like [liuvariablereduction] focus on computational efficiency by reducing decision variables. However, these formulations remain tailored to specific objectives, requiring modifications to adapt to changing priorities.

%Scheduling problems are formulated using mathematical models that define an objective function and a set of constraints. The choice of formulation significantly impacts the ability to generate efficient schedules. [blazewiczsurvey] provides a survey on scheduling formulations, categorizing them based on different objectives. Some well-known formulations include:

%\begin{itemize}
    %\item \textbf{Jackson (1955)} introduced a formulation for minimizing maximal lateness in single-machine scheduling.
    %\item \textbf{Bruno et al. (1973)} extended the shortest processing time (SPT) rule by incorporating weighted completion times to account for job priorities.
    %\item \textbf{Zambrano Rey (2020)} proposed a just-in-time scheduling formulation using a mean squared error (MSE) function around due dates, penalizing both early and late completions. Due to the complexity, he applied genetic algorithms (GA) and particle swarm optimization (PSO) for near-optimal solutions.
%\end{itemize}

%Despite these advancements, most formulations are designed for specific scheduling goals. Adapting them to different objectives often requires significant modifications, limiting their flexibility in dynamic environments. Some studies, such as [liuvariablereduction], attempt to improve computational efficiency by reducing the number of decision variables, but they still lack a unified model that can handle diverse scheduling objectives without reformulation.

%\subsection*{Optimization Methods}
Once a scheduling formulation is defined, various methods can be employed to find a solution, broadly categorized into heuristics, metaheuristics, and mathematical optimization []. 

Heuristic methods, such as priority rules, schedule generation schemes, forward-backward scheduling, and justification schemes, construct feasible schedules quickly based on predefined rules. They are computationally efficient but lack flexibility and do not guarantee optimality []. %For instance, priority rules like earliest due date (EDD) and shortest processing time (SPT) offer predictable results but fail to explore the full solution space, making them unsuitable for critical applications.

Metaheuristic algorithms, including GA, simulated annealing (SA), and tabu search (TS), iteratively refine solutions to escape local optima, often achieving better results than simple heuristics []. While computationally more expensive, they offer a balance between solution quality and efficiency. However, they still lack global optimality guarantees and require tuning [].

Mathematical optimization, like ILP, provides exact solutions by formulating scheduling as a system of linear equations with integer constraints []. Techniques like branch-and-bound and branch-and-cut explore the solution space, ensuring global optimality []. However, job scheduling is NP-hard [], and solving large-scale instances remains computationally challenging, despite advances in solver efficiency.




%The formulation can be solved using heuristic, metaheuristic and mathematical optimization approaches.

%Once a scheduling formulation is defined, different methods are used to solve the problem. These can be broadly classified into heuristic, metaheuristic, and mathematical optimization approaches.

%\subsubsection*{Heuristic Approaches}
%Heuristic methods, such as priority rules, schedule generation schemes (SGS), forward-backward scheduling (FBS), and justification schemes, construct feasible schedules quickly using predefined rules. They are computationally efficient and suitable for large-scale problems but do not guarantee optimality. For example, priority rules schedule jobs based on fixed criteria, such as earliest due date (EDD) or shortest processing time (SPT), but they do not explore the full search space and may lead to suboptimal solutions. While heuristics provide quick and predictable results, they lack flexibility and are unsuitable for critical applications where optimal solutions are needed.

%\subsubsection*{Metaheuristic Approaches}
%Metaheuristic algorithms offer an alternative to simple heuristics by iteratively refining solutions to approach near-optimality. These include genetic algorithms (GA), simulated annealing (SA), and tabu search (TS). Unlike heuristics, metaheuristics explore the search space more effectively, allowing them to escape local optima. However, they still lack guarantees of global optimality and may require extensive tuning. Their computational cost is higher than heuristics but significantly lower than exact optimization methods, making them practical for medium to large-scale problems.

%\subsubsection*{Mathematical Optimization}
%Mathematical optimization methods provide precise, globally optimal solutions to scheduling problems. Mixed Integer Linear Programming (ILP) is one of the most widely used techniques, formulating the scheduling problem as a set of linear equations with integer constraints. ILP uses branch-and-bound and branch-and-cut techniques to systematically explore the solution space. Unlike heuristics and metaheuristics, ILP guarantees optimality but can be computationally expensive, especially for large-scale problems due to the NP-hard nature of job scheduling. Recent advancements focus on improving solver efficiency, but ILP remains impractical for extremely large scheduling problems.

%\section*{Related Works}

%Heuristic solutions were proposed deal with scheduling jobs, like priority rules, Schedule generation scheme, Forward‐backward scheduling and Justification schemes. These methods requires low computational power, so they are powerful tools for large scale problems, however it does not guarantee optimal solution. For example, priority rules are a set a predefined rules that guide the scheduling process, it does fully explore the search space. So these methods are not recommended for critical problems when we need to actually achieve the optimal solution.

%When we want to get an approximately optimal solution meta-heuristic algorithms are another approach. These algorithms are usually inspired in natural fenomenon that have computational intelligence. They often use iterations to evolute and get near the optimal solution. They still don't guarantee the optimal solution, but can often get better results than simple heuristic solutions and are still less computationally costly when it comes to exact algorithms, so they can still be explored in medium to large scale problems. A few examples are genetic algorithms, simulated anneling, and taboo search.

%Heuristic solutions are more obvious solutions, it can be similar to a greedy approach, where we just place the most valuable or with the closest deadline first, and keep iterating until we place all the items. It is very predictable. On the other hand, genetic algorithms can come up with solutions that are not easy to interpret why that decision was made, the only thing we know is that it was the solution that gave the minimum (or maximum) reward on the objective function.

%Another approach is to define a mathematical formulation containing an objective function, a set of constraints, and treat it as a mathematical optimization using mixed integer linear programming (ILP). This method uses a relaxation on the discrete problem, use linear programming to solve the set of equations and then do a branch and cut approach to check if it is the optimal equation or not. Differently from previous methods, ILP provides the exact optimal solution, so it have a vision of the whole situation and peak the best scheduling given the information received. Job scheduling is a NP-hard problem, so finding the optimal solution, may take exponential time in the worst case. ILP method takes on average less time to find the optimal solution, since it uses branch and cut approach. Nevertheless, this method may be infeasible in so practical large scale situations.

%The algorithms talked earlier are used for optimization, however we still need to provide a mathematical formulation for the problem. Jacek Blazewicz provides a survey of the several mathematical programming formulations used in the context of scheduling optimization. 

%Jackson proposes a formulation for minimizing the maximal lateness on a single machine. Bruno et al. proposed a generalization of the shortest processing time (SPT) rule by adding weights to each job and try to minimize the completion time. Gabriel Zambrano Rey proposed a formulation to address the just-in-time paradigm, he used a mean squared error around the due date, so the objective function penalize both late items and items that world too early, given the complexity of the problem he used GA and PSO to get a near-optimal solution. However, each technique is tailored for an specific situation, if we want to change the behavior of the scheduling or even provide a mixed interpretation for different jobs, we would need to propose or model another formulation.

%Several other studies [7, 8] proposes novel formulations for the scheduling problem. However, their focus is mostly for improving the performance. For example, Anbang Liu proposed a formulation with fewer decision variables, reducing the complexity of the final decision. However, we still  don't have a more unified formulation capable of handling a more diverse scenario depending only on the items properties


%\section*{Study Case}

%The development team is responsible to create create new features, fix bugs and provide software updates, while a separate team is in charge of validating the software. The releases that should be tested are appended into a list, and the assembler takes this list generates an schedule to determine which releases should be validated in following days. If the software is approved it is released to the client, else it goes back to the development team. This pipeline is illustrated in fig ???. 

%[PUT FIGURE HERE]

%Each item in the list has a predefined time it takes to complete, a due date, and an importance value attributed to it. It also has external dependencies that must be finished before the item can be released to the client. At last, the validation team has a daily capability that may vary over time.

\section*{Study Case}

The software development team is responsible for implementing new features, fixing bugs, and providing updates, while a separate validation team ensures the quality and reliability of each release. The pipeline operates as follows: newly completed software releases are added to a queue, and a scheduling system determines which releases should be validated in the upcoming days. If a release passes validation, it is deployed to the client; otherwise, it is sent back to the development team for further improvements. This process is illustrated in Figure \ref{fig:pipeline}.

\begin{figure}[h]
    \centering
    %\includegraphics[width=\linewidth]{figure_placeholder}
    \caption{Software validation pipeline.}
    \label{fig:pipeline}
\end{figure}

Each release in the queue has a predefined validation time, a due date, and a priority value. Additionally, some releases have external dependencies that must be completed before deployment. The validation team operates under a daily capacity constraint, which may fluctuate over time due to resource availability.

Different releases require distinct scheduling strategies. Critical bug fixes must be validated immediately, while security updates follow a just-in-time approach to ensure compliance with the latest standards.

\section*{Notation}

The notation used in the formulation is presented in Table \ref{tab:notation}, while Table \ref{tab:notation2} defines additional symbols used throughout the paper. Subscript indices are used for iterative variables, while superscripts primarily denote static indices in constraint definitions.

\begin{table}[h]
    \centering
    \caption{Notation used in the mathematical formulation.}
    \label{tab:notation}
\end{table}

\begin{table}[h]
    \centering
    \caption{Notation used in the mathematical formulation.}
    \label{tab:notation2}
\end{table}

%\section*{Problem Formulation}

%The proposed objective function tries to maximize the summation of the reward minus the penalty. The Ext function defines the state of the external dependencies of each item depending on the time t.

%[Equation]

%The reward and penalty functions depend on the decision variable x, and the V and P matrices. V and P are what define the behavior of each item, as the behavior of each item has a different shape along time depending on the desired paradigm the item should follow.

%[Equation reward]

%[Equation penalty]

%The Ext function checks when the expected date of each external dependency given by the W matrix and returns a status to whether the penalty should or shouldn't be applied to the model.

%[Equation Ext dep]

%We also have to define the constraints, in this case we must that each item cant be scheduled more than once, the sum of weights of the items scheduled for a day cant be bigger than the capacity for that time, and the solution may only present 0s and 1s.

%[Equation Constraints]

\section*{Problem Formulation}

The objective function aims to maximize the total reward while minimizing penalties, ensuring an optimal scheduling decision. The external dependency function, denoted as \textit{Ext}, evaluates the status of each item's dependencies at time \( t \).

\begin{equation}
    Equation
\end{equation}

%The reward and penalty functions depend on the decision variable \( x \) and the V and P matrices, which define the scheduling behavior of each item. The time-dependent shape of these functions varies based on the desired scheduling paradigm.

%The reward and penalty functions depend on the decision variable \( x \) and the matrices \( V \) and \( P \), which are the core components that enable the model’s adaptability. These matrices shape the scheduling behavior of each item over time, allowing the model to mirror different scheduling paradigms. This parametric control over scheduling dynamics ensures it can accommodate a diverse range of optimization goals within a single formulation.

The reward and penalty functions depend on the decision variable \( x \) and the matrices \( V \) and \( P \), which are the components that enable the model’s adaptability. These matrices shape the scheduling behavior of each item over time. This parametric control over scheduling dynamics ensures it can accommodate a diverse range of optimization goals within a single formulation.

\begin{equation}
    Equation
\end{equation}

\begin{equation}
    Equation
\end{equation}

The \textit{Ext} function determines whether penalties should be applied based on the expected completion time of external dependencies, as defined by the E matrix.

\begin{equation}
    Equation
\end{equation}

Additionally, the model is subject to the following constraints:

\begin{itemize}
    \item Each item can be scheduled at most once.

    \begin{equation}
        Equation
    \end{equation}

    \item The total weight of scheduled items on any given day must not exceed the system’s capacity.

    \begin{equation}
        Equation
    \end{equation}
    
    \item Decision variables must be binary.
    
    \begin{equation}
        Equation
    \end{equation}
\end{itemize}]

\section*{Benchmark}

To validate the capability of our model to match the global optimal solution of different scheduling objectives, we adapted several formulations from the literature. The selected benchmark formulations are:

\begin{itemize}
    \item \textbf{Maximize Early Items (MEI) []}: Prioritizes scheduling the maximum number of items before their due dates, without considering the lateness of items that exceed their deadlines.
    \item \textbf{Minimize Total Lateness (MTT) []}: Seeks to minimize the total accumulated lateness across all scheduled items, focusing on reducing overall delay rather than prioritizing early completions.
    \item \textbf{Early-Lateness Balance (ELB) []}: A hybrid approach combining MEI and MTT, aiming to maximize early completions while also minimizing total lateness.
    \item \textbf{Just-in-Time (JIT) []}: Encourages scheduling items close to their due dates, avoiding both excessive earliness and lateness.
\end{itemize}

%Since some functions aim to minimize penalties, they may prefer not to schedule any items for not being penalized, so we put an additional term penalizing the items that were not scheduled.

Since certain objective functions prioritize minimizing penalties, the model may not schedule any items to avoid incurring penalties. Hence, an additional term is introduced to penalize unscheduled items, ensuring that the model seeks an optimal scheduling solution rather than avoiding assignments altogether.

%\section*{Benchmark}

%We adapted some formulations found in the literature, it will be used to validate the capability of our model to match the global optimal of different scheduling objective functions. The formulation used are:

%\begin{itemize}
    %\item \textbf{Maximize Early Items (MEI) []}: This formulation guarantees the maximum quantity of items scheduled before the due date, not caring about how late the other items are
    %\item \textbf{Minimize Total Lateness (MTT) []}: It tryes to minimize the amount of lateness time is accumulated considering the sum of all items
    %\item \textbf{Early-Lateness Balance (ELB) []}: It combine MEI and MTT, trying to maximize amount of early items but also accounts for the total lateness
    %\item \textbf{JIT []}: This metric induces the items to be scheduled near the due date, the idea is to not have late items, but also don't want the job to be done too early 
%\end{itemize}

\section*{Optimization Method}

%Since solving ILP directly is computationally complex, the problem is initially relaxed by removing the integer constraints, allowing classical LP solvers, such as the Simplex Method, to find an optimal solution in the continuous space. This relaxation provides a lower bound (for minimization problems) or upper bound (for maximization problems) for the ILP solution.

ILP is used to obtain the exact optimal solution. Unlike Linear Programming, which allows continuous values, ILP restricts decision variables to integer values, making it suitable for scheduling problems where tasks are either assigned or not. To enforce integer constraints, ILP solvers use the Branch-and-Bound, a recursive approach inspired by divide-and-conquer techniques []. The algorithm proceeds as follows:

\begin{itemize}
    \item \textbf{Solve the LP Relaxation}: The problem is solved without integer constraints, yielding a continuous optimal solution.
    %\item \textbf{Check Integer Feasibility}: If all decision variables are integer-valued, this solution is optimal for ILP.
    \item \textbf{Branching}: If any variable has a fractional value, the algorithm creates two subproblems by imposing additional constraints. If all decision variables are integers, this solution is optimal for that branch.
    \item \textbf{Bounding and Pruning}: The LP relaxation of each subproblem is solved. If a branch yields a worse objective function value than the current best integer solution, it is pruned.
    \item \textbf{Iteration}: The process continues recursively until all branches are explored or eliminated, ensuring the best integer solution is found.
\end{itemize}

%This approach guarantees optimality while efficiently navigating the exponential search space inherent in ILP problems.

%\section*{Optimization Method}

%Since we want to evaluate the behavior of our formulation, we opted to use ILP to find the exact optimal solution. For solving the problem with the constraint of being an integer solution, ILP uses a relaxation technique, where it remove the constraint of being integer and uses classical LP methods like simplex method to find the optimal solution. Provind an upper bound for the ILP problem.

%The algorithm then uses a branch and bound approach, similar to divide and conquer. It checks whether the solution presented integer solutions, if the solution is not integer, it adds another constraint to divide the feasible solutions in two. The algorithm keeps dividing the search space, finding the optimal solution for the relaxed case and checking if the result returned only integers. If the optimal solution to the relaxed problem is integer, it is the optimal solution for the ILP problem.

\section*{Numerical Results}

\subsection*{Data Properties}

The simulations use synthetic data to simplify the analysis while avoiding biases associated with a static dataset. The data in each simulation is either fixed or randomly sampled from a uniform or normal distribution. Table \ref{tab:data_generation} details the generation methods and parameters used.

\begin{table}[h]
    \centering
    % Add your table here
    \caption{Data generation methods and parameters.}
    \label{tab:data_generation}
\end{table}

To introduce a seasonal effect, due dates are sampled from a bimodal distribution, creating periods of high and low workload demand. This distribution pattern is illustrated in Figure \ref{fig:bimodal_due_dates}.

\begin{figure}[h]
    \centering
    % Add your figure here
    \caption{Bimodal distribution of due dates.}
    \label{fig:bimodal_due_dates}
\end{figure}


%\subsection*{Data properties}

%The simulations are executed using synthetic data to facilitate evaluating different scenarios and removing any bias given by a static database. The data used in each simulation is either constant or sampled from a uniform or normal distribution. Table ??? shows the method and parameters used to generate the data. A bimodal distribution was used to generate the due date to generate a small sazonal behavior, as we can see in figure ???.

%[Put table here]

%[Put figure here]

%\subsection*{Scheduling score}

%Before we evaluate the formulation on more complex scenario, lets check how well the model can match the global optimum of the alternative formulations. Here we want to demonstrate the simplicity of altering the schedule behavior without modifying the model. Tables ???, ???, ??? and ??? shows the result of the simulations considering each metric presented in the benchmark section.

%[Put Table]

%As we can see, in each case the proposed model was able to match the same global optimum as the model created specifically from that objective function. This supports the idea that our model is able to provide more flexibility to capture the essence of different formulations without needing reformulations.

%Now we provide a mixed scenario where the items have distintic properties for the scheduling process. In this case, as shown in table ???, our model presented the best final result on the mixed metric, with a big disparity. The other objective functions presented the best results when evaluated on their metrics, however, when seem the overall result our model provided the best scheduling to maximize the mixed behavior metric.

%[Put Table]

\subsection*{Scheduling Score}

Before evaluating the model in more complex scenarios, we first assess its ability to match the global optimal solutions of the benchmark formulations. This analysis demonstrates how easily the scheduling behavior can be adjusted without modifying the underlying model. Tables~\ref{tab:mei}, \ref{tab:mtt}, \ref{tab:elb}, and \ref{tab:jit} present the results for each benchmark metric.

\begin{table}[h]
    \centering
    % Add your table here
    \caption{Simulation results for benchmark formulations.}
    \label{tab:benchmark_results}
\end{table}

As shown in the results, the proposed model successfully achieved the same global optimum as the formulations explicitly designed for each scheduling objective. This confirms that our model can flexibly adapt to different scheduling paradigms without requiring structural reformulations.

Next, we evaluate a mixed scenario, where scheduling decisions must account for items with distinct properties. As shown in Table~\ref{tab:mixed_results}, our model outperforms all individual formulations in optimizing the mixed-behavior metric, with a significant margin. While the specialized formulations perform best under their respective metrics, our model delivers the most balanced scheduling strategy, integrating multiple behaviors.

\begin{table}[h]
    \centering
    % Add your mixed scenario table here
    \caption{Simulation results for the mixed scheduling scenario.}
    \label{tab:mixed_results}
\end{table}

\subsection*{Time Complexity Analysis}

To evaluate the execution time of the optimization process, we set the variance parameter of the capacity to zero, ensuring that capacity remains constant.

Figure \ref{fig:time_complexity} presents two plots to analyze the impact of different parameters on execution time. In the first plot, we fix the number of items to be scheduled and vary the scheduling period. In the second plot, we fix the time horizon and vary the number of items. Additionally, in Figure \ref{fig:time_complexity_3d}, we iterated over both variables, providing a detailed perspective on execution time as a function of both item count and scheduling period.

\begin{figure}[h]
    \centering
    \begin{subfigure}{0.45\textwidth}
        \centering
        %\includegraphics[width=\textwidth]{placeholder.png}
        \caption{One}
        \label{fig:subcaption1}
    \end{subfigure}
    \hfill
    \begin{subfigure}{0.45\textwidth}
        \centering
        %\includegraphics[width=\textwidth]{placeholder.png}
        \caption{Two}
        \label{fig:subcaption2}
    \end{subfigure}
    \caption{Two images.}
    \label{fig:time_complexity}
\end{figure}

\begin{figure}[h]
    \centering
    % Insert your figure here, for example:
    %\includegraphics[width=0.8\textwidth]{placeholder.png}
    \caption{Execution time as a function of the number of items and scheduling period.}
    \label{fig:time_complexity_3d}
\end{figure}

As observed in the results, execution time increases exponentially with the number of days and items, which aligns with expectations, given that the scheduling problem is \textbf{NP-hard}. This behavior underscores the computational complexity associated with solving large-scale scheduling instances.

%\subsection*{Time complexity}

%To evaluate the optimization execution time we let the variance parameter of the capacity to zero, so the capacity is only the mean in every timestamp. In figure ??? we ploted two graphics, in the first we fixed the quantity of items to be scheduled and varied the period of time we are considering the scheduling, in the second plot we fixed the time and varied the item's quantity. In figure ??? we iterated trhou both variables to get a more complete understanding of the time given the different quantity of items and days.

%[Put figure]

%As we can see, the time complexity increases exponentially with the number of days and items, which is an expected behavior given that the scheduling problem is NP-hard.

\section*{Discussion}

Our model introduces flexibility in scheduling by adjusting item properties rather than modifying the formulation itself. However, the choice of parameters in generating the Value and Penalty matrices must be carefully calibrated to prevent unintentional prioritization of specific items, ensuring a balanced scheduling outcome.

While the model successfully adapts to different scheduling paradigms, it incurs higher computational costs compared to traditional formulations. It is well-suited for small to medium-sized problems, but given the NP-hard nature of job scheduling, solving large-scale instances remains computationally expensive. To address this, metaheuristic algorithms could be employed to find near-optimal solutions.

One limitation of the current model is that it does not account for interdependencies between tasks, only external constraints, as incorporating such relationships would introduce non-linearity. Future work will explore linearization techniques or Mixed Integer Nonlinear Programming (MINLP) approaches to handle interdependencies.

\section*{Conclusion}

This study proposed a ILP-based scheduling model for software validation, capable of dynamically adapting to different scheduling objectives based on items properties, eliminating the need to reformulate the objective function.

The model demonstrated its ability to replicate the global optimal solutions of classical scheduling paradigms simply by adjusting item parameters. Additionally, it scheduled mixed-priority tasks, proving its versatility. However, simulations highlighted the scalability limitations of ILP for large systems, suggesting that integrating metaheuristic approaches could improve computational feasibility.



%\section*{Discussion}

%The parameters used to generate Value and Penalty matrices of each item must be chosen careful, since the system behavior depends on these values, the intensity of each item must be adjusted so the model does not prioritize one item over the other unintentionally. 

%The proposed model improves the flexibility but presents a bigger execution time when compared to the other formulations. It fits well for small and medium sized problems. However, since it is an NP-hard problem, for large scales it would be interesting to use metaheuristic algorithms to find near-optimal solutions.

%The proposed model does not account for inter dependencies, only external, as the solution becomes a non linear expression. For future work we intend add the inter dependency and use linearization techniques or MINLP to find the optimal solution

%\section*{Conclusion}

%We proposed a solution for the scheduling problem on software validation using a ILP formulation able to provide a varying scheduling behavior depending on the item's properties guaranteeing without needing to change the model's parameter itself. 

%We checked our model was capable of matching the global optimal of other classical objective functions just by altering the item's properties, also tested on a scenario that mixed items that should be scheduled according to different behaviors. We also presented a simulation to showcase the scalability limitations of ILP, that should be adapted using metaheuristic algorithms applied for large systems.


\section*{Importances}

x - severitity
y - number of persons impacted
z - product strategic relevance
w - valor agregado

\section*{References}

1 - Optimization Algorithms in Project Scheduling

2 - Mathematical programming formulations for machine scheduling: A survey

3 - Scheduling a production line to minimize maximum tardiness

4 - Padberg, M.W., and Grotschel, M. (1985), "Polyhedral computations" in : E.L.Lawler, J.K. Lenstra, A.H .G. Rinnooy Kan and D. Shmoys (eds.), The Travelling Salesman Problem,Wiley,Chichester, 307-360.

5 - Scheduling independent tasks to reduce mean finishing time 

6 - Solving the flexible job-shop just-in-time scheduling problem
with quadratic earliness and tardiness costs Gabriel Zambrano Rey

7 - A Novel Integer Linear Programming Formulation for Job-Shop
Scheduling Problems

8 - An Innovative Formulation Tightening Approach for Job-Shop
Scheduling

%\section*{Old}

%When software was not much present in our lives, companies often released one version that would stay static for perhaps years, and it did not have much changes, and the hardware was not so diversified. But the diversity has being magnified a lot. So large companies often have to work if an increasing big amount of software releases, changes, and so on.

%In the old days, software development management was very poor, since the software was much less complex, with less functionalities, and usually independent with no integration with third part systems. However, the size of the software is increasing, more features are required and there may be hundreds of integration with APIs, cloud services and etc. In the really early days we could get a description of what the client wanted and provide it to them. But as the computers became more functional, the software became increasingly more complex. 

%Project management became evidently necessary, and we started breaking the software in several feature, and tasks that must be completed to get the final product. This way we could deliver small functional functionalities to the client. And with this idea, was born the agile methodologies. 

%Job scheduling is often used in manufacturing industries to garanteeing the best use of resources and minimizing production costs. As the software development world is becoming more fragmented and complex, job scheduling techniques are strong methods that can improve the resource utilization, project outcomes and customer satisfaction. As organizations face increasing demands for timely and cost-effective delivery, developing adaptable scheduling methodologies becomes essential.

%The job scheduling problem (JSP) has been extensively studied, yet its complexity continues to present challenges in real-world applications. Factors such as varying deadlines, conflicting priorities, or different objective paradgmas necessitate tailored solutions for different scenarios. For example, some projects must be expedited to meet urgent business goals, while others require precise timing to avoid premature or late completion. Addressing this diversity requires different mathematical models that can adapt to multiple objectives and constraints, ensuring an optimal balance between competing priorities.

%Despite extensive research on job scheduling optimization, most mathematical models are tailored to specific objectives, such as minimizing lateness, reducing makespan, or ensuring just-in-time completion. This narrow focus limits their applicability across diverse scenarios where multiple objectives or dynamic priorities coexist. This model also requires someone with a deep understanding of the process and optimization methods, which creates a difficulty to implement scheduling techniques without a lot of time preparing someone. Additionally, many existing formulations require substantial modification or entirely separate models to accommodate different goals, making them inflexible for real-world use cases where priorities can shift rapidly. 

%This research addresses the aforementioned gap by proposing an Integer Linear Programming (ILP) model that integrates multiple scheduling objectives within a single formulation. The model achieves adaptability by parameterizing key aspects such as deadlines, penalties for lateness or earliness, and resource constraints, allowing practitioners to prioritize different objectives without altering the core structure. This flexibility not only reduces the complexity of deploying scheduling optimization across varying scenarios but also enhances its practical relevance, particularly in dynamic environments like software development and project management. By enabling seamless customization of objectives within a unified framework, this work provides a significant step toward bridging theoretical advancements with practical applications in job scheduling.

\end{document}
